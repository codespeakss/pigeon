<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Coordinator → Brokers → Clients</title>
    <style>
        body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 20px; }
        .broker { margin-left: 20px; }
        .clients { margin-left: 40px; }
        .card { padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; margin: 8px 0; background:#fafafa }
        .small { color: #666; font-size: 0.9em }
        
        /* MODIFIED: 修改 .controls 样式以实现右上角定位 */
        .controls {
            font-size: 0.9em;
            position: absolute; /* 使用绝对定位 */
            top: 20px;          /* 距离顶部 20px (与 body padding 一致) */
            right: 20px;         /* 距离右侧 20px (与 body padding 一致) */
        }
    </style>
</head>
<body>
    <div class="controls">
        <label for="refreshInterval">自动刷新间隔: </label>
        <select id="refreshInterval">
            <option value="0">禁用</option>
            <option value="1000" selected>1 秒</option>
            <option value="5000">5 秒</option>
            <option value="30000">30 秒</option>
            <option value="60000">1 分钟</option>
        </select>
    </div>

    <h1>Coordinator → Brokers → Clients</h1>
    <p class="small">This page queries the coordinator for brokers and clients and shows the hierarchical relationship.</p>

    <div id="coordinator" class="card">
        <strong>Coordinator</strong>
        <div id="coordInfo" class="small">loading...</div>
    </div>

    <div id="brokers"></div>

    <script>
        // Base URL for coordinator API (matches README/test/send.html use of 127.0.0.1:30081)
        const BASE = 'http://127.0.0.1:30081';

        // NEW: 用于存储 setInterval 返回的 ID
        let refreshTimer = null;

        async function fetchCoordinatorInfo() {
            try {
                const res = await fetch(BASE + '/');
                const text = await res.text();
                document.getElementById('coordInfo').textContent = text.trim();
            } catch (err) {
                document.getElementById('coordInfo').textContent = 'Failed to fetch coordinator: ' + err;
            }
        }

        async function fetchBrokers() {
            try {
                const res = await fetch(BASE + '/api/v1/brokers');
                if (!res.ok) throw new Error('status ' + res.status);
                const brokers = await res.json();
                renderBrokers(brokers);
            } catch (err) {
                const el = document.getElementById('brokers');
                el.innerHTML = '<p class="small">Failed to fetch brokers: ' + err + '</p>';
            }
        }

        function createBrokerElement(broker) {
            const wrapper = document.createElement('div');
            wrapper.className = 'card broker';

            const title = document.createElement('div');
            title.innerHTML = `<strong>Broker: </strong> <span>${broker.id || broker.id}</span>`;
            wrapper.appendChild(title);

            const meta = document.createElement('div');
            meta.className = 'small';
            meta.textContent = `assigned_at: ${broker.assigned_at || ''}  last_seen: ${broker.last_seen || ''}  remote_addr: ${broker.remote_addr || ''}`;
            wrapper.appendChild(meta);

            const clientsContainer = document.createElement('div');
            clientsContainer.className = 'clients small';
            clientsContainer.textContent = 'loading clients...';
            wrapper.appendChild(clientsContainer);

            // fetch clients for this broker
            (async () => {
                try {
                    const res = await fetch(BASE + '/api/v1/clients?broker_id=' + encodeURIComponent(broker.id));
                    if (!res.ok) throw new Error('status ' + res.status);
                    const clients = await res.json();
                    // defensive: some responses may be null or not an array
                    if (!Array.isArray(clients) || clients.length === 0) {
                        clientsContainer.textContent = 'no clients';
                        return;
                    }
                    clientsContainer.innerHTML = '';
                    const ul = document.createElement('ul');
                    clients.forEach(c => {
                        const li = document.createElement('li');
                        li.textContent = c.id || c.client_id || c.name || JSON.stringify(c);
                        ul.appendChild(li);
                    });
                    clientsContainer.appendChild(ul);
                } catch (err) {
                    clientsContainer.textContent = 'failed to fetch clients: ' + err;
                }
            })();

            return wrapper;
        }

        function renderBrokers(brokers) {
            const el = document.getElementById('brokers');
            el.innerHTML = ''; // 清空旧数据
            if (!Array.isArray(brokers) || brokers.length === 0) {
                el.innerHTML = '<p class="small">No brokers found.</p>';
                return;
            }

            brokers.forEach(broker => {
                const be = createBrokerElement(broker);
                el.appendChild(be);
            });
        }

        // --- NEW: 自动刷新逻辑 ---

        /**
         * 1. 将所有数据获取操作组合到一个函数中
         */
        function refreshData() {
            // 在刷新时重置 "loading..." 状态，提供即时反馈
            document.getElementById('coordInfo').textContent = 'loading...';
            // 注意: renderBrokers 会自动清空 #brokers, 所以这里不需要显式清空
            
            fetchCoordinatorInfo();
            fetchBrokers();
        }

        /**
         * 2. 创建一个函数来设置或清除定时器
         */
        function setupAutoRefresh(intervalMs) {
            // 清除任何现有的定时器
            if (refreshTimer) {
                clearInterval(refreshTimer);
                refreshTimer = null;
            }

            // 如果间隔大于 0 (即 "禁用" 选项未被选中), 则设置新的定时器
            if (intervalMs > 0) {
                refreshTimer = setInterval(refreshData, intervalMs);
            }
        }

        // 3. 获取下拉菜单元素
        const intervalSelect = document.getElementById('refreshInterval');

        // 4. 为下拉菜单添加 'change' 事件监听器
        intervalSelect.addEventListener('change', () => {
            const newInterval = parseInt(intervalSelect.value, 10);
            setupAutoRefresh(newInterval);
        });

        // 5. 页面加载时的初始操作
        
        // 立即加载一次数据
        refreshData();

        // 根据默认选中的值启动定时器
        const defaultInterval = parseInt(intervalSelect.value, 10);
        setupAutoRefresh(defaultInterval);

        // --- 结束: 自动刷新逻辑 ---
    </script>
</body>
</html>